
# 12장 - 채팅 시스템 설계

## 1. 개요

채팅 시스템에서 클라이언트는 서로 직접 통신하지 않고, 네트워크 통신 프로토콜을 사용하여 채팅 서비스를 제공하는 서버에 접속한다. 일반적인 클라이언트/서버 애플리케이션처럼 채팅 시스템에서도 클라이언트가 서버에 요청을 보내는 구조이다.

채팅 시스템은 실시간성이 중요하므로 클라이언트와 서버 간의 연결을 **지속적으로 유지(Keep-alive)** 해야 한다. 이를 통해 매번 3-way 핸드셰이크를 수행할 필요가 없어지고, 연결 비용을 줄일 수 있다.

하지만 **HTTP는 요청 기반의 프로토콜**이기 때문에, 서버가 임의의 시점에 클라이언트에게 메시지를 보내는 데에는 적합하지 않다. 이러한 한계를 극복하기 위한 몇 가지 기술들이 존재한다.

---

## 2. 메시지 전송 방식

### 2.1 폴링 (Polling, HTTP/HTTPS)

* 클라이언트가 주기적으로 서버에 새 메시지가 있는지 요청하는 방식이다.
* 구현은 간단하지만, 서버 자원이 불필요하게 소모된다는 단점이 있다.
* 메시지가 자주 오지 않아도 클라이언트는 계속해서 요청을 보내야 한다.

---

### 2.2 롱 폴링 (Long Polling, HTTP/HTTPS)

* 폴링의 비효율성을 개선한 방식이다.
* 클라이언트는 새 메시지가 오거나 타임아웃이 발생할 때까지 연결을 유지한다.
* 메시지를 수신하면 기존 연결을 종료하고 다시 서버에 요청을 보낸다.
* **단점:**

  1. 메시지를 보내는 클라이언트와 수신하는 클라이언트가 서로 다른 채팅 서버에 연결되어 있을 수 있다.

     * HTTP 서버는 일반적으로 무상태(stateless)이며, 로드 밸런싱을 위해 **라운드 로빈 알고리즘**을 사용하므로, 수신 클라이언트를 관리하고 있는 서버가 메시지를 수신하지 못할 수 있다.
  2. 서버는 클라이언트가 연결을 해제했는지 판단할 수 없다.
  3. 여전히 비효율적이다.

     * 메시지를 거의 받지 않는 클라이언트도 타임아웃이 발생할 때마다 서버에 재접속해야 한다.

---

### 2.3 웹소켓 (WebSocket)

* **서버가 클라이언트에게 비동기적으로 메시지를 보낼 수 있는 가장 일반적인 방식이다.**
* **초기 연결은 HTTP/HTTPS**로 시작하며, 이후 서버가 `HTTP 101 Switching Protocols` 응답을 보내면 **웹소켓으로 프로토콜이 업그레이드**된다.
* 연결은 클라이언트가 시작하며, **한 번 연결되면 항구적이며 양방향 통신이 가능**하다.
* 서버는 연결된 클라이언트에게 실시간으로 메시지를 보낼 수 있다.

#### 방화벽 우회에 유리한 이유

* 웹소켓은 기본적으로 HTTP/HTTPS 포트(80, 443)를 사용한다.
* 대부분의 방화벽은 포트 번호, IP 주소, 프로토콜을 기준으로 트래픽을 제한하지만, 일반적으로 **80, 443 포트는 차단하지 않기 때문에** 웹소켓은 방화벽이 있는 환경에서도 잘 동작한다.

---

## 3. 결론

* 채팅 시스템은 **양방향, 비동기적 메시지 전송**이 가능해야 한다.
* HTTP 기반 방식(폴링, 롱 폴링)은 제한적이고 비효율적인 단점이 존재한다.
* **웹소켓은 설계와 구현이 직관적이고, 효율적이며 실시간 통신에 적합한 기술**이다.
* 웹소켓을 사용하면 메시지를 보낼 때와 받을 때 동일한 프로토콜을 사용할 수 있어 시스템의 일관성을 유지하기 쉽다.

---

## 4. 주의사항

* 웹소켓은 연결을 **항구적으로 유지**해야 하므로, **서버 측에서 연결 상태를 효율적으로 관리**해야 한다.
* 불필요한 연결 유지로 인한 자원 낭비나 장애를 방지하기 위해 적절한 타임아웃, 핑-퐁(ping-pong) 메커니즘 등을 고려해야 한다.
* (핑-퐁은 연결이 끊겼는지 감지하고, 연결을 유지하기 위한 주기적 신호 교환이다.)

---

## 5. 추가 질문 - 웹소켓 연결이 끊기는 경우

* 웹소켓 연결은 다음과 같은 경우에 끊길 수 있다.

  * **네트워크 불안정**으로 인한 연결 끊김
  * **클라이언트 또는 서버의 명시적인 연결 종료**
  * **서버 재시작 혹은 장애 발생**
  * **채팅방 삭제**와 같은 기능적 이벤트로 서버에서 의도적으로 연결 종료
  * **방화벽, 프록시 또는 로드 밸런서 설정**에 의한 세션 종료
* 따라서 연결 유지를 위한 **상태 모니터링 및 재연결 로직**이 필요하다.


채팅 시스템은 실시간 통신이 요구되므로 웹소켓을 사용하는 것이 적절하지만, **통신을 제외한 대부분의 기능은 일반적인 HTTP 기반 요청/응답 방식**으로 충분히 처리할 수 있다.

## 2. 시스템 구성

### 2.1 무상태 서비스

* 로그인, 회원가입, 프로필 조회 등의 기능은 **전통적인 요청/응답 구조**로 처리한다.
* 이러한 서비스는 **무상태(Stateless)** 이며, 로드밸런서 뒤에 위치한다.
* 로드밸런서는 클라이언트 요청을 적절한 서비스 인스턴스로 분배하는 역할을 한다.
* 백엔드 구현은 모놀리식 또는 마이크로서비스 구조로 구성할 수 있으며, 현재 시장에는 이러한 기능을 완제품 형태로 제공하는 솔루션도 많기 때문에, 반드시 직접 구현할 필요는 없다.

---

### 2.2 상태 유지 서비스

* **채팅 서비스는 상태를 유지해야 하는 유일한 구성요소**이다.
* 채팅을 위해서는 각 클라이언트와 서버 간에 **지속적인 네트워크 연결(WebSocket)** 이 필요하다.
* 일반적으로 서버가 살아있으면 다른 서버로의 연결 전환은 발생하지 않으므로, 초기 연결 시점에서 **적절한 채팅 서버를 선택하는 전략이 중요**하다.
* 서버 간 부하 분산이 되지 않으면 특정 서버에 부하가 집중될 수 있으므로 이를 방지해야 한다.

---

### 2.3 제3자 서비스 연동

* 가장 중요한 제3자 서비스는 **푸시 알람(Push Notification)** 시스템이다.
* 앱이 실행 중이지 않더라도, 사용자는 새 메시지에 대한 알림을 받아야 하므로 푸시 알람 연동이 필수적이다.

---

### 2.4 규모 확장성(Scalability)

* **SPOF(Single Point of Failure)** 가 발생하지 않도록 구성 요소를 수평 확장 가능한 구조로 분산 배치한다.
* 구성 요소는 다음과 같이 나뉜다:

| 구성 요소    | 역할                     |
| -------- | ---------------------- |
| 채팅 서버    | 실시간 메시지 중개 및 웹소켓 처리    |
| 접속 상태 서버 | 사용자 접속 여부 추적 및 상태 관리   |
| API 서버   | 로그인, 회원가입, 프로필 변경 등 처리 |
| 알림 서버    | 푸시 알람 전송               |
| 키-값 저장소  | 채팅 이력 저장               |

* 클라이언트는 채팅 서버와의 웹소켓 연결을 **절대로 끊지 않고 유지**해야 실시간 메시지 전송이 가능하다.

---

## 3. 저장소 설계

### 3.1 데이터 유형

채팅 시스템에서는 두 종류의 주요 데이터를 다룬다:

1. **일반적인 사용자 데이터**

   * 사용자 프로필, 설정, 친구 목록 등
   * **관계형 데이터베이스**가 적합하다.
   * 고가용성과 확장성을 위해 다중화(Mirroring) 및 샤딩(Sharding) 기술을 사용한다.

2. **채팅 이력 데이터**

   * 대량의 메시지 데이터를 저장
   * 다음과 같은 패턴을 고려해야 한다:

#### 저장 조건:

* 메시지 데이터의 **양이 매우 많다.**
* 주로 사용하는 데이터는 **최근 메시지**이다.
* **무작위 접근(random access)** 또는 **특정 시점으로의 점프(jump)** 가 필요하다.
* **1:1 채팅**의 경우, 읽기와 쓰기 비율은 **약 1:1**이다.

#### 저장소 선택:

* **키-값 저장소**는 수평 확장이 쉬우며, 접근 지연시간이 짧아 대규모 메시지 저장에 적합하다.
* 반면, **관계형 데이터베이스**는 롱테일 데이터를 처리하는 데 부적합하며, 인덱스가 늘어날수록 무작위 접근 비용이 증가한다.
* 따라서 안정적인 채팅 시스템에서는 일반적으로 **키-값 저장소를 채택**한다.

---

## 4. 상세 설계 (3단계)

### 4.1 서비스 탐색

서비스 탐색의 목적은 **클라이언트에게 가장 적절한 채팅 서버를 연결해주는 것**이다. 서버의 물리적 위치, 부하 상태, 지연 시간 등을 기준으로 서버를 추천한다.

#### 동작 순서:

1. 사용자가 접근을 시작한다.
2. 로드밸런서는 가장 쾌적한 상태의 API 서버 중 하나로 요청을 전달한다.
3. API 서버는 클라이언트에게 적절한 채팅 서버를 추천한다.
4. 클라이언트는 해당 채팅 서버와 **웹소켓 연결을 맺는다.**

---

## 5. 접속 장애 처리

### 5.1 접속 상태 판별 전략

* 네트워크가 일시적으로 끊겼다고 해서 사용자의 접속 상태를 즉시 변경하는 것은 적절하지 않다.
* **박동 이벤트(Heartbeat)** 를 기반으로 접속 상태를 유지한다.

  * 마지막 ping/pong 이벤트가 **X초 이내**에 정상 응답되었으면 접속 중으로 판단한다.
  * 이를 통해 불필요한 접속 종료/복구를 줄이고 네트워크 상태 변화에 유연하게 대응할 수 있다.

---

## 6. 요약

* 채팅 시스템은 실시간성을 확보하기 위해 **웹소켓 기반의 지속 연결**이 필수이다.
* 나머지 기능은 무상태 HTTP 요청/응답 구조로 처리 가능하다.
* 저장소는 **관계형 DB + 키-값 저장소**의 하이브리드 구성이 적절하다.
* 확장성과 안정성을 고려한 **서버 분리 및 역할 분담**이 중요하다.
* 접속 장애 시에도 안정적인 서비스 유지를 위한 **박동 기반 상태 판별**이 필요하다.

---
